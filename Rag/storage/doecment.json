["武汉大学学报(信息科学版)\nGeomaticsandInformationScienceofWuhanUniversity\nISSN1671-8860,CN42-1676/TN\n《武汉大学学报(信息科学版)》网络首发论文\n题目：结合边缘归属与双向扫描的栅格Voronoi图生成算法\n作者：王磊，宋志学，殷楠，程钢\nDOI：10.13203/j.whugis20220110\n收稿日期：2022-03-01\n网络首发日期：2022-07-15\n引用格式：王磊，宋志学，殷楠，程钢．结合边缘归属与双向扫描的栅格Voronoi图生成\n算法[J/OL]．武汉大学学报(信息科学版).\nhttps://doi.org/10.13203/j.whugis20220110\n网络首发：在编辑部工作流程中，稿件从录用到出版要经历录用定稿、排版定稿、整期汇编定稿等阶\n段。录用定稿指内容已经确定，且通过同行评议、主编终审同意刊用的稿件。排版定稿指录用定稿按照期\n", "．武汉大学学报(信息科学版).\nhttps://doi.org/10.13203/j.whugis20220110\n网络首发：在编辑部工作流程中，稿件从录用到出版要经历录用定稿、排版定稿、整期汇编定稿等阶\n段。录用定稿指内容已经确定，且通过同行评议、主编终审同意刊用的稿件。排版定稿指录用定稿按照期\n刊特定版式（包括网络呈现版式）排版后的稿件，可暂不确定出版年、卷、期和页码。整期汇编定稿指出版年、卷、期、页码均已确定的印刷或数字出版的整期汇编稿件。录用定稿网络首发稿件内容必须符合《出版管理条例》和《期刊出版管理规定》的有关规定；学术研究成果具有创新性、科学性和先进性，符合编辑部对刊文的录用要求，不存在学术不端行为及其他侵权行为；稿件内容应基本符合国家有关书刊编辑、出版的技术标准，正确使用和统一规范语言文字、符号、数字、外文字母、法定计量单位及地图标注等。为确保录用定稿网络首发的严肃性，录用定稿一经发布，不得修改论文题目、作者、机构名称和学术内容，只可基于编辑规范进行少量文字的修改。出版确认：纸质期刊编辑部通过与《中国学术期刊（光盘版）》电子杂志社有限公司签约，在《中国\n", "准，正确使用和统一规范语言文字、符号、数字、外文字母、法定计量单位及地图标注等。为确保录用定稿网络首发的严肃性，录用定稿一经发布，不得修改论文题目、作者、机构名称和学术内容，只可基于编辑规范进行少量文字的修改。出版确认：纸质期刊编辑部通过与《中国学术期刊（光盘版）》电子杂志社有限公司签约，在《中国\n学术期刊（网络版）》出版传播平台上创办与纸质期刊内容一致的网络版，以单篇或整期出版形式，在印刷出版之前刊发论文的录用定稿、排版定稿、整期汇编定稿。因为《中国学术期刊（网络版）》是国家新闻出版广电总局批准的网络连续型出版物（ISSN2096-4188，CN11-6037/Z），所以签约期刊的网络版上网络首发论文视为正式出版。\n——————————————\n收稿日期：2022-03-01\n项目资助：国家自然科学基金（41801318）；河南省重点研发与推广专项（科技攻关）（212102310432）；河\n南理工大学青年骨干教师资助计划（2019XQG-03）；河南理工大学博士基金（B2017-14，\nB2017-09）。\n第一作者：王磊，博士，副教授，主要从事GIS相关算法与可视化研究。wl890627@163.com\n通讯作者：程钢，博士，教授。chenggang1218@163.comDOI:10.13203/j.whugis20220110\n引用本文：WANGLei，SONGZhixue，YINNan，etal.ARasterVoronoiDiagramGeneratingAlgorithmUsing\nEdgeAttributionandBilateralScanning[J].GeomaticsandInformationScienceofWuhanUniversity,2022，DOI：\n", "n，etal.ARasterVoronoiDiagramGeneratingAlgorithmUsing\nEdgeAttributionandBilateralScanning[J].GeomaticsandInformationScienceofWuhanUniversity,2022，DOI：\n10.13203/j.whugis20220110(王磊，宋志学，殷楠，等.结合边缘归属与双向扫描的栅格Voronoi图生成算法[J].武汉大学学报·信息科学版，2022，DOI：10.13203/j.whugis20220110)\n结合边缘归属与双向扫描的栅格Voronoi图生成算法\n王磊1宋志学1殷楠1程钢1\n1河南理工大学测绘与国土信息工程学院，河南焦作，454000\n摘要：Voronoi图是计算几何领域中的一个重要研究方向，其生成算法是该领域的关键技术。确\n定归属算法符合计算机的离散特征，是精度最优的栅格Voronoi图生成算法之一，但该算法在海\n量数据处理时效率不高。针对这一问题，提出一种基于结合边缘归属与双向扫描的栅格Voronoi\n生成算法。在深入探究确定归属算法精度优异和效率较低原因的基础上，首先将数据边界栅格\n通过确定归属计算赋予Voronoi区域归属，建立3×3的邻域模板，进行正向扫描；然后在深入\n", "i图生成算法之一，但该算法在海\n量数据处理时效率不高。针对这一问题，提出一种基于结合边缘归属与双向扫描的栅格Voronoi\n生成算法。在深入探究确定归属算法精度优异和效率较低原因的基础上，首先将数据边界栅格\n通过确定归属计算赋予Voronoi区域归属，建立3×3的邻域模板，进行正向扫描；然后在深入\n剖析正向扫描结果的基础上，通过逆向纠错确保所有栅格归属的正确性；最后利用不同规模的数据进行了实验对比。结果表明，所提算法具有与确定归属算法相同的精度，但却省去80%以\n上的计算量，效率提高四倍以上，且数据规模越大，算法优势越明显。\n关键词：Voronoi图；栅格扫描；确定归属\n中图分类号：P208文献标志码：A\n\nVoronoi图（以下简称V图）是计算几\n何学中一种重要的数据结构，具有自然邻近、\n动态稳定等特性，被广泛应用于气象学、地\n理学、晶体学、信息科学、机器人路径规划、\n警力部署、森林消防、商业圈划分等领域[1-5]。\n其中V图的高效、准确生成是其诸多应用顺\n利实现的关键，国内外学者对V图生成算法\n进行了许多研究，其成果主要分为两大类：\n矢量算法和栅格算法。\n矢量方法可以分为直接法和间接法。直\n接法就是直接生成要素的V图，如增量法[6]、\n分治法[7]和并行法[8,9]等；而间接法是先生成\nV图的对偶——Delaunay三角网，然后生成\n", "是其诸多应用顺\n利实现的关键，国内外学者对V图生成算法\n进行了许多研究，其成果主要分为两大类：\n矢量算法和栅格算法。\n矢量方法可以分为直接法和间接法。直\n接法就是直接生成要素的V图，如增量法[6]、\n分治法[7]和并行法[8,9]等；而间接法是先生成\nV图的对偶——Delaunay三角网，然后生成\nV图[10-12]；此外还有半线法[13]等。矢量方法的精度优异，但对于线与面数据集而言，边\n界一般是不规则的，在矢量空间中难以用连\n续的计算步骤对不规则的边界生长过程进\n行刻画，因此矢量方法只能较好的生成离散\n空间点要素的V图，对包含线、面的全要素\nV图生成是较为困难的[14]。由于矢量算法的不足，许多学者将目光\n转向了栅格，并提出了基于栅格数据的V图\n生成算法。栅格空间中生成V图的方法可以\n分成两类：一类是基于均匀栅格结构的方法，\n如距离变换算法[15]、扩张算法[16]、确定归属\n算法[17,18]、栅格扫描算法[19]等；另一类是基\n于常规四叉树结构的层次栅格结构方法[20]，\n如层次算法[21]、细分算法[2]等。\n其中，确定归属算法是精度最优的算法\n之一，它通过计算空白栅格与所有种子点的\n欧氏距离，根据距离远近来确定其Voronoi\n区域归属。但由于其时间复杂度高，在处理\n海量数据时的时间效率较低。栅格扫描算法\n", "另一类是基\n于常规四叉树结构的层次栅格结构方法[20]，\n如层次算法[21]、细分算法[2]等。\n其中，确定归属算法是精度最优的算法\n之一，它通过计算空白栅格与所有种子点的\n欧氏距离，根据距离远近来确定其Voronoi\n区域归属。但由于其时间复杂度高，在处理\n海量数据时的时间效率较低。栅格扫描算法\n利用邻近栅格种子点的传递，使空白栅格从其邻近栅格处获取最近种子点信息，而不必\n与所有种子点进行距离计算与比较。其时间\n复杂度相对优异，但由于扫描的不完备性，\n其精度难以得到保证。\nV图的生成算法在效率及精度方面存\n在的问题，在一定程度上限制了其应用的广ÍøÂçÊ×·¢Ê±¼ä£º2022-07-1509:59:50\nÍøÂçÊ×·¢µØÖ·£ºhttps://kns.cnki.net/kcms/detail/42.1676.TN.20220714.1203.001.html度和深度。为此本文基于传统的确定归属算\n法和栅格扫描算法，提出了一种基于结合边\n缘归属与双向扫描的栅格V图生成算法，首\n先确定边缘栅格的归属，然后通过正向扫描\n与逆向强纠错，结合邻近栅格Voronoi归属\n的传递减少算法的时间复杂度，在保留确定\n归属算法较好精度的同时，提高算法的效率。\n1改进算法原理\n1.1正向扫描\n确定归属算法优异的精度是空白栅格\n与所有种子点进行欧式距离计算得到的（此\n过程以下称为：确定归属计算），时间效率\n", "的归属，然后通过正向扫描\n与逆向强纠错，结合邻近栅格Voronoi归属\n的传递减少算法的时间复杂度，在保留确定\n归属算法较好精度的同时，提高算法的效率。\n1改进算法原理\n1.1正向扫描\n确定归属算法优异的精度是空白栅格\n与所有种子点进行欧式距离计算得到的（此\n过程以下称为：确定归属计算），时间效率\n较低是由于每个空白栅格都要进行确定归属计算导致。因此，本文利用栅格扫描算法\n中邻近栅格Voronoi归属的传递性减少算法\n的时间复杂度。\n首先，建立起算区域。利用邻近栅格Voronoi归属传递的特性，需要存在一部分\n拥有Voronoi归属的栅格。本文在平面区域\n的外围通过确定归属计算，建立一层拥有\nVoronoi归属的栅格点作为起算区域，如图1\n所示。\n建立一个3×3的扫描模板，如图2所\n示，并利用该模板分别对栅格数据进行自上\n而下的正向扫描和自下而上的逆向纠错。\n在正向扫描过程中，如果空白栅格3×3\n邻域中𝑄1、𝑄2、𝑄3、𝑄4同属一个Voronoi\n区域，则给予空白栅格相同的Voronoi归属\n（如图3(a)），否则就是找到了边界（如图\n3(b)），此时利用确定归属计算，确定空白栅\n格的Voronoi归属。\n在一次正向扫描过后，平面区域内所有\n栅格都被赋予了Voronoi归属，但其中存在\n一部分归属错误（如图4所示）。\n\n", "属一个Voronoi\n区域，则给予空白栅格相同的Voronoi归属\n（如图3(a)），否则就是找到了边界（如图\n3(b)），此时利用确定归属计算，确定空白栅\n格的Voronoi归属。\n在一次正向扫描过后，平面区域内所有\n栅格都被赋予了Voronoi归属，但其中存在\n一部分归属错误（如图4所示）。\n\n图1建立起算区域图23×3邻域图Fig.1SetuptheStartingAreaFig.23×3Neighborhoods\n\n\n(a)四邻域归属相同(b)四邻域归属不同\n图3正向扫描两种情况\nFig.3TwoCasesoftheForwardScanning\n\n(a)正向扫描结果(b)正向扫描错误点(c)确定归属算法结果\n图4正向扫描及正向扫描错误点和确定归属算法结果\nFig.4ResultsofForwardScan,ForwardScanErrorPointsandAttributionAlgorithm\n图4(a)为正向扫描结果，图4(b)中红色\n区域部分为正向扫描后Voronoi归属错误的\n栅格，图4(c)是确定归属算法所得V图。可\n以看出归属错误的栅格均分布在正确的\nVoronoi区域边界附近，并且具有向右下方\n延伸的特点。\n1.2逆向纠错\n正向扫描利用空白栅格八邻域中𝑄1、\n𝑄2、𝑄3、𝑄44个依赖栅格，判断其Voronoi\n归属。当空白栅格处于正确Voronoi区域边\n界，而其𝑄1、𝑄2、𝑄3、𝑄44个邻域属于相\n同Voronoi区域时，算法会将该空白栅格误\n", "oronoi区域边界附近，并且具有向右下方\n延伸的特点。\n1.2逆向纠错\n正向扫描利用空白栅格八邻域中𝑄1、\n𝑄2、𝑄3、𝑄44个依赖栅格，判断其Voronoi\n归属。当空白栅格处于正确Voronoi区域边\n界，而其𝑄1、𝑄2、𝑄3、𝑄44个邻域属于相\n同Voronoi区域时，算法会将该空白栅格误\n判为非Voronoi边界栅格，利用邻近栅格Voronoi归属传递的特性，赋予空白栅格与\n其相同的Voronoi归属，进而导致空白栅格\n的归属错误。如图5(a)所示，栅格P1位于\nVoronoi区域A和C的边界上（实际到种子\n点A的距离大于到种子点C的距离），本应\n该进行确定归属计算，但由于其4邻域𝑄1、\n𝑄2、𝑄3、𝑄4同属于种子点A，因此算法将\n其错误归属到Voronoi区域A，对于下一栅\n格P2的扫描也会出现同样的误判，如图5(b)\n所示。而对于图5(c)种的栅格P3，其四邻域\n𝑄1、𝑄2、𝑄3、𝑄4所属的Voronoi区域不同，\n算法判断其为Voronoi边界栅格，从而进行\n确定归属计算，得到正确的Voronoi归属。根据扫描规则及邻域𝑄1、𝑄2、𝑄3、𝑄4的空\n间特征，在正向扫描的结果中，每一个\nVoronoi区域（无论正确与否）的左上边界\n一定经过了确定归属计算，能够保证其归属\n", "𝑄3、𝑄4所属的Voronoi区域不同，\n算法判断其为Voronoi边界栅格，从而进行\n确定归属计算，得到正确的Voronoi归属。根据扫描规则及邻域𝑄1、𝑄2、𝑄3、𝑄4的空\n间特征，在正向扫描的结果中，每一个\nVoronoi区域（无论正确与否）的左上边界\n一定经过了确定归属计算，能够保证其归属\n的正确性。如图6(a)所示，栅格𝐴1、𝐴2位于Voronoi区域A和C的边界上且Voronoi归\n属错误，𝐶1、𝐶2、𝐶3、𝐶4、𝐶5其邻域𝑄1、\n𝑄2、𝑄3、𝑄4所属Voronoi区域不同，进行确\n定归属计算，确保栅格归属的正确性。因此，\n每个错误Voronoi边界右方和下方的栅格归\n属均是正确的。\n已知错误边界的右方和下方栅格点归\n属正确，可以利用邻近栅格Voronoi归属传\n递的特性进行反向传递，在正向扫描基础上\n逆向纠错。所以在从右到左，从下到上纠错\n过程中，只要在3×3邻域模板中不全属于同\n一个Voronoi区域，那就有可能是错误点，\n如图7(a)所示。对所有满足此条件的栅格进\n行确定归属计算，即可修复正向扫描出现的\n错误，利用邻近栅格Voronoi归属传递的特\n性进行正确性传递，如图7(b)所示。从右到\n左，从下到上的遍历顺序可以保证3×3邻域\n模板首先接触到的是归属错误的栅格，因此\n", "个Voronoi区域，那就有可能是错误点，\n如图7(a)所示。对所有满足此条件的栅格进\n行确定归属计算，即可修复正向扫描出现的\n错误，利用邻近栅格Voronoi归属传递的特\n性进行正确性传递，如图7(b)所示。从右到\n左，从下到上的遍历顺序可以保证3×3邻域\n模板首先接触到的是归属错误的栅格，因此\n首先被改正，但正确的边界也会被计算。虽然存在多余计算，但确保了栅格归属的正确。\n\n(a)确定归属算法(b)归属传递错误点(c)确定归属计算点\n图5正向扫描错误原因\nFig.5CausesofForwardScanErrors\n\n(a)正向扫描结果(b)确定归属算法结果(a)边界纠错(b)正确性传递\n图6错误边界原因图7逆向纠错两种情况\nFig.6CausesofBoundaryErrorsFig.7TwoCasesofReverseErrorCorrection\n\n2实验分析\n本文算法所用编程语言为Python3.8，\n硬件环境为CPU：AMDRyzen75800H，\nGPU：NVIDIAGeForceRTX3060。\n2.1正确性验证\n确定归属算法的精度优异，相较于矢量\nVoronoi图，其误差在一个格网以内。因此\n本文选择确定归属算法作为算法精度评判\n的基准。\n在平面上选取500×500的栅格范围，\n随机选取50～1000个种子点，进行10000\n次实验，均得到与确定归属算法相同的结果，\n正确率均为100%。图4(c)和图8(a)分别为\n利用确定归属算法和本文算法生成的V图\n（种子点数为60），可以看出两种算法可以\n得到相同的V图。\n", "法精度评判\n的基准。\n在平面上选取500×500的栅格范围，\n随机选取50～1000个种子点，进行10000\n次实验，均得到与确定归属算法相同的结果，\n正确率均为100%。图4(c)和图8(a)分别为\n利用确定归属算法和本文算法生成的V图\n（种子点数为60），可以看出两种算法可以\n得到相同的V图。\n(a)本文算法结果(b)本文算法归属计算足迹图8本文算法结果及确定归属计算足迹\nFig.8AlgorithmsinThisPaperanditsCalculating\nFootprint\n2.2效率对比\n为验证本文算法相对确定归属算法的\n效率优势，统计了本文算法进行确定归属计\n算的栅格轨迹及占总栅格的比率。图8(b)中\n的红色区域为本文算法进行确定归属计算\n的栅格，图9为在500×500的栅格范围中\n选取不同数量的种子点时，两种算法所用时\n间的比率及本文算法的确定归属计算比率。\n从两图中可以看出本文算法仅对少数栅格\n进行了确定归属计算，相对于确定归属算法\n省去了大部分不必要的计算，从而节省计算\n时间，大大提高算法的效率。\n表1所示为在不同数据规模下，两种算\n法生成V图所用的时间及本文算法的确定\n归属计算比率。图10展示了在500×500的\n栅格范围中选取不同数量的种子点时，两种\n算法所用的时间对比，可以看出，随着种子\n点数的增加，两种算法所消耗的时间不断增\n加。但确定归属算法时间增长趋势较为陡峭，\n", "提高算法的效率。\n表1所示为在不同数据规模下，两种算\n法生成V图所用的时间及本文算法的确定\n归属计算比率。图10展示了在500×500的\n栅格范围中选取不同数量的种子点时，两种\n算法所用的时间对比，可以看出，随着种子\n点数的增加，两种算法所消耗的时间不断增\n加。但确定归属算法时间增长趋势较为陡峭，\n而本文算法时间增长趋势较为平缓，且种子点数越多，本文算法的效率优势越明显。\n图9两种算法所用的时间比率及本文算法确定归\n属计算比率\nFig.9TimeRatiosoftheTwoAlgorithmsand\nAttributionCalculationRatioofAlgorithms\ninThisPaper\n表1不同算法生成V图所用时间\nTab.1TimeTakenbytheTwoAlgorithmstoGenerateVoronoiDiagrams\n栅格大小种子数量/个确定归属算法时\n间t1/s本文算法时间t2/st2/t1确定归属计\n算比率\n500×500503.8311.0620.2770.108\n1007.3921.9640.2650.137\n20014.3144.0040.2790.169\n1000×100010029.8886.6170.2210.085\n20058.22912.7670.2190.103\n30089.30019.9080.2220.113\n3000×3000200528.42594.9860.1790.054\n5001365.447234.3730.1710.067\n10002717.316503.9670.1850.086\n\n\n图10确定归属算法与本文算法时间对比\nFig.10ComparisonoftheTimeTaken\nbytheTwoAlgorithms\n3结语\n本文在深入分析确定归属算法在精度、\n效率方面优势及不足的基础上，提出一种基于结合边缘归属与双向扫描的栅格V图生\n成算法。着重分析正向扫描栅格Voronoi归\n", "0确定归属算法与本文算法时间对比\nFig.10ComparisonoftheTimeTaken\nbytheTwoAlgorithms\n3结语\n本文在深入分析确定归属算法在精度、\n效率方面优势及不足的基础上，提出一种基于结合边缘归属与双向扫描的栅格V图生\n成算法。着重分析正向扫描栅格Voronoi归\n属错误的原因，提出逆向纠错来改正Voronoi归属。从而通过优先确定边界栅格\n的Voronoi归属及正向扫描与逆向纠错来生\n成V图，并进行了相关实验验证了算法的精\n度与效率。实验表明：本文提出的结合边缘\n归属与双向扫描的栅格V图生成算法能够\n保留确定归属算法优秀的精度，同时减少需\n要进行确定归属计算的栅格，大大提高了算\n法的效率。本文算法虽然尚不能解决并行计\n算等问题，但其算法思想可以应用在全要素\nV图生成和球面V图生成邻域，后续将进一\n步研究本文算法在球面格网空间中的应用。\n\n参考文献\n[1]ShouHuahao,YuanZiwei,MiaoYongwei,etal.The\nVoronoiDiagramofTwo-DimensionalShapewith\nAlgebraicCurveBoundary[J].ComputerScience\nandApplication,2011,1(2):39-43(寿华好,袁子\n薇,缪永伟，等.以代数曲线为边界的二维形\n体的Voronoi图[J].计算机科学与应用,2011,\n1(2):39-43)\n[2]ShouHuahao,YuanZiwei,MiaoYongwei,etal.A\nSubdivisionAlgorithmforVoronoiDiagramof\nPlanarPointSet[J].JournalofGraphics,2013,34(2):\n", ",2011,\n1(2):39-43)\n[2]ShouHuahao,YuanZiwei,MiaoYongwei,etal.A\nSubdivisionAlgorithmforVoronoiDiagramof\nPlanarPointSet[J].JournalofGraphics,2013,34(2):\n1-6(寿华好,袁子薇,缪永伟，等.一种平面点集Voronoi图的细分算法[J].图学学报,2013,\n34(2):1-6)\n[3]LiuQingping,ZhaoXuesheng,WangLeietal.AAaster\nVoronoiDiagramGenerationAlgorithmBasedon\nHorizontal-LongitudinalScanning[J].Acta\nGeodaeticaetCartographicaSinica,2019(3):\n393-399(刘青平,赵学胜,王磊,等.横-纵扫\n描的Voronoi图栅格生成算法[J].测绘学报,\n2019(3):393-399)\n[4]MengLei,ZhangJunwei,WangXiaoting,etal.An\nImprovedIncrementalAlgorithmforVoronoi\nDiagram[J].JournalofImageandGraphics,A,2010,\n15(6):978-984(孟雷,张俊伟,王筱婷，等.一\n种改进的Voronoi图增量构造算法[J].中国图\n象图形学报A,2010,15(6):978-984)\n[5]ShouHuahao.TheVoronoiDiagramof\nTwo-DimensionalShapewithAlgebraicCurve\nBoundary[J].ComputerScience&Application,\n2011,1(2):39-43\n[6]SiHaifei,ShiZhen,WangHongjian,etal.Research\nonMulti-pointDynamicTargetVoronoiDiagram\nGenerationAlgorithminTwo-Dimensional\nSpace[J].JournalofJinlingInstituteofTechnology,\n2020,36(1):1-5(司海飞,史震,王宏健，等.二\n", "i-pointDynamicTargetVoronoiDiagram\nGenerationAlgorithminTwo-Dimensional\nSpace[J].JournalofJinlingInstituteofTechnology,\n2020,36(1):1-5(司海飞,史震,王宏健，等.二\n维空间多点动态目标Voronoi图生成算法研究[J].金陵科技学院学报,2020,36(1):1-5)\n[7]ShamosMI,HoeyD.Closest-pointproblems[C]\n∥Proceedingsofthe16thAnnual\nSymposiumonFoundationsofComputerScience.\nWashington,DC:IEEEComputerSociety,\n1977:151-162\n[8]TuWensen,WangJiajia,etal.Raster-basedMethodforVoronoiDiagramUsingGPUParallel\nTechnology[J].ModernElectronicsTechnique,\n2015,38(4):66-68+72(屠文森,汪佳佳.\nVoronoi图栅格生成算法GPU并行实现[J].现\n代电子技术,2015,38(4):66-68+72)\n[9]LiShuyan,CaoHan,LiuNiling,etal.Generation\nParallelAlgorithmResearchofVoronoi\nDiagram[J].JournalofLightIndustry,2010,\n25(1):105-109(李淑艳,曹菡,刘妮玲.Voronoi\n图的并行生成算法研究[J].郑州轻工业学院学\n报(自然科学版),2010,25(1):105-109)\n[10]HeldM,etal.VORONOI:AnEngineering\nApproachtotheReliableandEfficient\nComputationofVoronoiDiagramsofPointsand\nLineSegments[J].ComputationalGeometry,\n2001,18(2):95-123\n[11]WuJianhua,DaiPeng,HuLieyun,etal.An\nAdaptiveVoronoiDiagramsAlgorithmfor\nMatchingMulti-scaleArealResidentialAreas[J].\nGeomaticsandInformationScienceofWuhan\n", "anhua,DaiPeng,HuLieyun,etal.An\nAdaptiveVoronoiDiagramsAlgorithmfor\nMatchingMulti-scaleArealResidentialAreas[J].\nGeomaticsandInformationScienceofWuhan\nUniversity,2022,47(2):304-312(吴建华,戴鹏,胡烈云.一种面向多尺度面状居民地匹配的\nVoronoi图自适应构建算法[J].武汉大学学\n报·信息科学版,2022,47(2):304-312)\n[12]WangLei,ZhangNa,YinNan,etal.AnAdaptive\nTerrainSimplificationAlgorithmBasedon\nCentroidalVoronoiDiagram[J].Geomaticsand\nInformationScienceofWuhan\nUniversity:1-10[2022-02-28].\nhttp://kns.cnki.net/kcms/detail/42.1676.TN.2021\n1008.1639.004.html(王磊,张娜,殷楠，等.一种\n利用质心Voronoi图对地形自适应简化的算法\n[J].武汉大学学报(信息科学\n版):1-10[2022-02-28].http://kns.cnki.net/kcms/de\ntail/42.1676.TN.20211008.1639.004.html)\n[13]OkabeA,BootsB,SugiharaK,etal.Spatial\nTessellations:ConceptsandApplicationsof\nVoronoiDiagrams[M].2nded.London:John\nWliey&Sons,Inc.2000\n[14]WangLei.QTM-BasedSphericalVoronoi\nDiagramGeneratingAlgorithmsandIts\nApplication[J].ActaGeodaeticaetCartographica\nSinica,2018,47(11):1561.(王磊.基于QTM的\n球面Voronoi图生成算法与应用[J].测绘学报,2018,47(11):1561)\n[15]ChenJun.ARaster-basedMethodforComputing\n", "aGeodaeticaetCartographica\nSinica,2018,47(11):1561.(王磊.基于QTM的\n球面Voronoi图生成算法与应用[J].测绘学报,2018,47(11):1561)\n[15]ChenJun.ARaster-basedMethodforComputing\nVoronoiDiagramsofSpatialObjectsUsingDynamicDistanceTransformation[J].\nInternationalJournalofGeographical\nInformationScience,1999,13(3):209-225\n[16]GuoLicai,WangFeng,HuangZhangjin,etal.A\nFastandRobustSeedFloodingAlgorithmon\nGPUforVoronoiDiagramGeneration[C].\nInternationalConferenceonElectrical&Control\nEngineering,2011\n[17]WangXinsheng,LiuJiyuan,ZhuangDafang,etal.\nNewRaster-BasedMethodforConstructing\nVoronoiDiagrams[J].JournalofChina\nUniversityofMining&Technology,2003(3):\n84-87(王新生,刘纪远,庄大方,等.一种新的\n构建Voronoi图的栅格方法[J].中国矿业大学\n学报,2003(3):84-87)\n[18]WangLei,ZhaoXuesheng,GuanYaqin,etal.A\nParallelAlgorithmforGeneratingSpherical\nVoronoiDiagramsinQTMSpace.[J].Geomatics\nandInformationScienceofWuhanUniversity,2017,42(5):691-696(王磊,赵学胜,官亚勤，等.\nQTM格网空间中的球面Voronoi图并行生成算\n法[J].武汉大学学报·信息科学版,2017,42(5):\n691-696)\n[19]ShihFY,WuYita,etal.FastEuclideandistance\ntransformationintwoScansUsinga3×3\nNeighborhood[J].ComputerVision&Image\nUnderstanding,2004,93(2):195-205\n[20]LiJiatian,ChenJun,ZhaoRenliang,etal.A\nBackwardInflationGeneratingMethodfor\nVoronoiDiagramBasedonLinearQuadtree\nStructure[j].ActaGeodaeticaetCartographica\n", "atian,ChenJun,ZhaoRenliang,etal.A\nBackwardInflationGeneratingMethodfor\nVoronoiDiagramBasedonLinearQuadtree\nStructure[j].ActaGeodaeticaetCartographica\nSinica,2008(2):236-242.(李佳田,陈军,赵仁亮,等.基于线性四叉树结构的Voronoi图反\n向膨胀生成方法[J].测绘学报,2008(2):\n236-242)\n[21]LiangEnhui,LinShihgang,etal.AHierarchical\nApproachtoDistanceCalculationUsingthe\nSpreadFunction[J].InternationalJournalof\nGeographicalInformationScience,1998,12(6):\n515-535\n\n\n\nARasterVoronoiDiagramGeneratingAlgorithmUsing\nEdgeAttributionandBilateralScanning\nWANGLei1SONGZhixue1YINNan1CHENGGang1\n1SchoolofSurveyingandLandInformationEngineeringHenanPolytechnicUniversity,Jiaozuo454000,China\nAbstract：Objectives：Voronoidiagramisanimportantresearchdirectioninthefield\nofcomputationalgeometry,andthegenerationalgorithmofVoronoidiagramisakey\ntechnologyinthisfield.Thedeterministicattributionalgorithm,whichmeetsthe\ndiscretecharacteristicsofcomputer,isoneofthemostaccuraterasterVoronoi\ndiagramgenerationalgorithms,butthealgorithmisnotefficientwhenprocessing\nlargeamountsofdata.Inthispaper,ArasterVoronoigenerationalgorithmbasedon\nthecombinationofedgeattributionandbidirectionalscanningisproposedtoaddress\nthisproblem.Methods：Basedonanin-depthinvestigationofthereasonsforthe\nexcellentaccuracyandlowefficiencyofthedeterministicattributionalgorithm,the\nVoronoiattributionofneighboringrasteristransferredbyattributionofit’sneighboringraster.Firstly,theboundaryrasterisgivenVoronoiregionattributionby\ndeterministicattributioncalculation,thena3×3neighboringdomaintemplateis\nestablished,andforwardscanningisperformedbyusingthedomaintemplate.Then,\n", "ionby\ndeterministicattributioncalculation,thena3×3neighboringdomaintemplateis\nestablished,andforwardscanningisperformedbyusingthedomaintemplate.Then,\nthecorrectnessofVoronoiattributionofalltherasterisensuredbyreverseerrorcorrectionbasedontheforwardscanningresults.Results：Experimentalcomparison\nusingdataofdifferentsizesshowsthat:(1)thealgorithminthispaperhasthesame\naccuracyasthedeterministicattributionalgorithm.(2)Comparedwiththe\ndeterministicattributionalgorithm,thealgorithminthispapersavesmorethan80%\nofthecomputation.(3)Thetimeefficiencyis4timesmorethanthatofthe\ndeterministicattributionalgorithm.Conclusions:TherasterVoronoigeneration\nalgorithmbasedonedgeattributionandbidirectionalscanningproposedinthispaper\nretainstheexcellentaccuracyofthedeterministicattributionalgorithmandgreatly\nimprovesthetimeefficiencyofthealgorithm,andthelargertheamountofdata,the\nmoreobvioustheadvantageofthealgorithm.\nKeywords：Voronoidiagram;rasterscan;determiningattribution\n\nFirstauthor:WANGLei,PhD,associateprofessor,specializesinGISalgorithmandvisualization.E-mail:\nwl890627@163.com\nCorrespondingauthor:CHENGGang,PhD,professor.E-mail:chenggang1218@163.com\nFoundationsupport:TheNationalNaturalScienceFoundationofChina(41801318);theKeyProjectofScience\nandTechnologyResearchofHenanProvince(212102310432);YoungBackboneTeachersFundingSchemeof\nHenanPolytechnicUniversity(2019XQG-03);DoctoralFoundationofHenanPolytechnicUniversity(B2017-14,\nB2017-09).\n", "#Git教程\n\n#基础篇\n\n##Git简介\n\nGit是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git由LinusTorvalds创建，最初目的是为更好地管理\nLinux内核开发而设计。它允许多个开发者在同一个项目上工作，而不必担心彼此的工作可能会发生冲突。\n\n##安装Git\n\n在不同的操作系统上安装Git的步骤略有不同：\n\n*在Windows上，可以从Git官网下载安装程序并运行。\n*在MacOSX上，可以通过Homebrew安装Git：\n\n`bashbrewinstallgit`\n\n*在Linux上，可以使用包管理器安装Git，例如在Ubuntu上：\n\n`bashsudoapt-getupdatesudoapt-getinstallgit`\n\n##Git基本配置\n\n配置用户信息是使用Git的第一步。在提交时，这些信息会记录在提交历史中。\n\n`bashgitconfig--globaluser.name\"你的名字\"gitconfig--globaluser.email\n\"你的邮箱\"`\n\n还可以检查所有配置信息：\n\n`bashgitconfig--list`\n\n##创建仓库\n\n要初始化一个新的Git仓库，使用`gitinit`命令：\n\n`bashgitinit`\n\n这将创建一个名为`.git`的子目录，其中包含所有的仓库元数据。\n\n##版本控制流程\n\nGit的版本控制流程通常包括：工作区的更改、暂存更改以及提交更改到仓库。\n\n1.查看文件状态：\n\n`bashgitstatus`\n\n1.将文件添加到暂存区：\n\n`bashgitadd<文件名>`\n\n1.提交更改：\n\n`bashgitcommit-m\"提交信息\"`\n\n##文件状态与工作区\n\nGit\n中的文件有三种状态：已提交（committed）、已修改（modified）和已暂存（staged）。一个工作区包含了实际的文件，而暂存区是一个准备好下次提交的文件列表。\n\n##提交更改\n\n", "名>`\n\n1.提交更改：\n\n`bashgitcommit-m\"提交信息\"`\n\n##文件状态与工作区\n\nGit\n中的文件有三种状态：已提交（committed）、已修改（modified）和已暂存（staged）。一个工作区包含了实际的文件，而暂存区是一个准备好下次提交的文件列表。\n\n##提交更改\n\n提交是Git中的基本操作，它会将暂存区的更改记录到仓库中。每次提交都会在仓库中创建一个快照，并允许之后恢复到该状态。\n`bashgitcommit-m\"描述性的提交信息\"`\n\n##查看提交历史\n\n要查看提交历史，可以使用`gitlog`命令：\n\n`bashgitlog`\n\n还可以使用多种选项来定制显示的日志输出。\n\n##撤销操作\n\n如果需要撤销操作，Git提供了几个命令：\n\n*撤销工作区的修改：\n\n`bashgitcheckout--<文件名>`\n\n*撤销暂存区的文件：\n\n`bashgitresetHEAD<文件名>`\n\n*撤销提交（创建一个新的提交来撤销之前的提交）：\n\n`bashgitrevert<提交ID>`\n\n##标签管理\n\n标签是指向特定提交的引用，通常用于版本发布。创建一个新标签：\n\n`bashgittag<标签名>`\n\n列出所有标签：\n\n`bashgittag`\n\n删除标签：\n\n`bashgittag-d<标签名>`\n\n查看标签信息：\n\n`bashgitshow<标签名>`\n\n推送标签到远程仓库：\n\n`bashgitpushorigin<标签名>`\n\n#分支管理\n\n##分支的概念\n\n", "shgittag<标签名>`\n\n列出所有标签：\n\n`bashgittag`\n\n删除标签：\n\n`bashgittag-d<标签名>`\n\n查看标签信息：\n\n`bashgitshow<标签名>`\n\n推送标签到远程仓库：\n\n`bashgitpushorigin<标签名>`\n\n#分支管理\n\n##分支的概念\n\n在Git中，分支是用来隔离开发工作的。每个分支都是一个独立的开发环境，互不影响。分支可以很方便地被创建和合并，因此许多开发者使用分支来进行特性开发、修复bug或者尝试新想法。\nGit的一个核心概念是几乎所有操作都是本地执行的，分支也不例外。这意味着你在本地创建或切换分支，不需要与远程仓库进行通信。\n\n##创建与合并分支\n\n在Git中创建新分支可以使用`gitbranch`命令，合并分支则使用`gitmerge`命令。\n\n```bash\n\n#创建新分支\n\ngitbranch\n\n#切换到新分支\n\ngitcheckout\n\n#创建新分支并立即切换到该分支\n\ngitcheckout-b\n\n#合并指定分支到当前分支\n\ngitmerge```\n\n##分支策略\n\n合理的分支策略可以帮助团队更有效地协作。一种常见的策略是GitFlow，它定义了一个围绕项目发布的分支模型，包括功能分支、发布分支、维护分支等。\n\n另一种策略是GitHubFlow，它更加简单灵活，适合持续交付的项目。在GitHub\nFlow中，`master`分支通常是稳定的，并且随时可以部署。所有新的开发都在基于`master`的特性分支上进行，一旦完成就可以合并回`master`。\n\n", "布的分支模型，包括功能分支、发布分支、维护分支等。\n\n另一种策略是GitHubFlow，它更加简单灵活，适合持续交付的项目。在GitHub\nFlow中，`master`分支通常是稳定的，并且随时可以部署。所有新的开发都在基于`master`的特性分支上进行，一旦完成就可以合并回`master`。\n\n##解决冲突\n当两个分支修改了同一部分代码并尝试合并时，就可能会出现冲突。Git无法自动合并这些更改，需要人工介入解决。\n\n解决冲突的过程通常包括以下步骤：\n\n1.运行`gitmerge`，Git会提示冲突发生。\n2.打开冲突文件，查找所有标记为冲突的地方，这些地方会被特殊的标记符号包围。\n3.编辑文件，解决所有冲突。\n4.使用`gitadd`命令标记冲突已解决。\n5.完成合并操作，如果需要，可以通过`gitcommit`命令提交更改。\n\n```bash\n\n#解决冲突后，添加文件标记冲突已解决\n\ngitadd\n\n#提交解决冲突后的合并\n\ngitcommit-m\"Resolvemergeconflict\"```\n\n##分支合并策略\n\nGit提供了不同的分支合并策略，例如默认的`merge`策略，它会创建一个新的合并提交来合并两个分支的历史。\n\n另一种策略是`rebase`，它会将一个分支的提交重新应用到另一个分支上。这样可以创建一个更线性的提交历史。\n\n```bash\n\n#使用rebase合并分支\n\ngitcheckoutgitrebase\n\n#如果在rebase过程中遇到冲突，解决冲突后\n\ngitaddgitrebase--continue\n\n", "略是`rebase`，它会将一个分支的提交重新应用到另一个分支上。这样可以创建一个更线性的提交历史。\n\n```bash\n\n#使用rebase合并分支\n\ngitcheckoutgitrebase\n\n#如果在rebase过程中遇到冲突，解决冲突后\n\ngitaddgitrebase--continue\n\n#完成rebase后，切换回基础分支并合并特性分支\ngitcheckoutgitmerge```\n\n使用`rebase`的好处是可以避免不必要的合并提交，但它会改变历史，因此在共享的分支上使用时需要谨慎。\n\n#远程仓库\n\n##远程仓库的作用\n\n远程仓库是位于互联网或其他网络中的服务器上的Git\n仓库。它可以让多个开发者共享一个项目，而不必将所有的文件和版本历史存储在本地计算机上。远程仓库的主要作用包括：\n\n***版本控制**：帮助团队成员之间同步和管理代码变更。\n***备份**：防止本地数据丢失后可以从远程仓库恢复。\n***协作**：多人可以同时工作在同一个项目上，提高开发效率。\n***代码审查**：通过PullRequests(PRs)等机制可以进行代码审查。\n\n##添加远程仓库\n\n要添加新的远程仓库，可以使用`gitremoteadd`命令。该命令需要两个参数：远程仓库的名称和远程仓库的URL。\n\n`bashgitremoteadd<remote-name><remote-url>`\n\n例如，添加一个名为`origin`的远程仓库：\n\n`bashgitremoteaddoriginhttps://github.com/username/repository.git`\n\n##推送到远程仓库\n\n", "\n`bashgitremoteadd<remote-name><remote-url>`\n\n例如，添加一个名为`origin`的远程仓库：\n\n`bashgitremoteaddoriginhttps://github.com/username/repository.git`\n\n##推送到远程仓库\n\n将本地的更改推送到远程仓库，可以使用`gitpush`命令。通常，这个命令后面会跟远程仓库的名称和要推送的分支名称。\n`bashgitpush<remote-name><branch-name>`\n\n例如，将本地的`master`分支推送到`origin`远程仓库：\n\n`bashgitpushoriginmaster`\n\n##从远程仓库拉取\n\n从远程仓库获取最新的更改并合并到本地分支，可以使用`gitpull`命令。这个命令会将远程仓库的指定分支的更改拉取到当前分支。\n\n`bashgitpull<remote-name><branch-name>`\n\n例如，从`origin`远程仓库的`master`分支拉取最新更改：\n\n`bashgitpulloriginmaster`\n\n##远程分支管理\n\n查看远程分支，可以使用`gitbranch`命令加上`-r`选项。\n\n`bashgitbranch-r`\n\n删除远程分支，可以使用`gitpush`命令加上`--delete`选项。\n\n`bashgitpush<remote-name>--delete<branch-name>`\n\n例如，删除`origin`远程仓库的`feature`分支：\n\n`bashgitpushorigin--deletefeature`\n\n##远程仓库的协作与贡献\n\n协作和贡献通常涉及以下步骤：\n\n1.**Fork**远程仓库。\n2.**Clone**Fork后的仓库到本地。\n3.创建新的**分支**进行开发。\n", "origin`远程仓库的`feature`分支：\n\n`bashgitpushorigin--deletefeature`\n\n##远程仓库的协作与贡献\n\n协作和贡献通常涉及以下步骤：\n\n1.**Fork**远程仓库。\n2.**Clone**Fork后的仓库到本地。\n3.创建新的**分支**进行开发。\n4.完成开发后，将分支**推送**到自己的Fork仓库。5.在原仓库发起**PullRequest**(PR)。\n6.维护者**审查代码**，并将其**合并**到主仓库。\n\n例如，将本地分支`feature`推送到自己Fork的远程仓库：\n\n`bashgitpushoriginfeature`\n\n之后，在GitHub或其他托管服务上发起PullRequest。\n\n#高级篇\n\n##变基\n\n变基（Rebase）是Git中用于整理提交历史的一种工具。它的主要作用是将一系列的提交按照原有顺序复制到另一个基底上。\n\n###基本原理\n\n当你进行变基操作时，Git会找到这些提交和目标基底（即你想要变基到的提交）的最近共同祖先，然后将每个提交从这个共同祖先开始重新应用。这样，你的提交历史就会看起来像是从目标基底直接分支出来的。\n\n###使用变基\n\n```bash\n\n#将当前分支变基到指定的\n\ngitrebase```\n\n##暂存区管理\n\n暂存区（StagingArea）是Git中的一个概念，它是一个准备提交的更改列表。\n\n###基本原理\n\n当你执行`gitadd`命令时，更改就会被添加到暂存区。然后你可以使用`gitcommit`将这些更改提交到仓库。\n\n###操作暂存区\n\n```bash\n\n#添加文件到暂存区\n\ngitadd\n\n", "\n暂存区（StagingArea）是Git中的一个概念，它是一个准备提交的更改列表。\n\n###基本原理\n\n当你执行`gitadd`命令时，更改就会被添加到暂存区。然后你可以使用`gitcommit`将这些更改提交到仓库。\n\n###操作暂存区\n\n```bash\n\n#添加文件到暂存区\n\ngitadd\n\n#查看暂存区状态\ngitstatus\n\n#取消暂存\n\ngitresetHEAD```\n\n##Git钩子\n\nGit钩子（Hooks）是在Git执行特定事件（如提交和合并）时触发的脚本。\n\n###基本原理\n\nGit钩子存放在仓库的`.git/hooks`目录下。当触发相应的事件时，Git会执行这个目录下的脚本。\n\n###使用Git钩子\n\n```bash\n\n#编辑钩子脚本\n\nvim.git/hooks/\n\n#使钩子脚本可执行\n\nchmod+x.git/hooks/```\n\n##子模块\n\n子模块（Submodules）允许你将一个Git仓库作为另一个Git仓库的子目录。\n\n###基本原理\n\n使用子模块可以帮助你管理项目中的第三方代码库。\n\n###使用子模块\n\n```bash\n\n#添加子模块\n\ngitsubmoduleadd\n\n#初始化子模块\n\ngitsubmoduleinit\n\n#更新子模块\n\ngitsubmoduleupdate```\n\n##GitLFS（大文件存储）\n\nGitLFS（LargeFileStorage）是一个Git扩展，用于改善大文件的存储和访问。\n\n###基本原理\n\nGitLFS通过将大文件的内容替换为指针，实际内容存储在服务器上，从而避免了大文件在仓库中的直接存储。\n\n###使用GitLFS\n\n```bash\n\n#安装GitLFS\n\ngitlfsinstall\n\n#跟踪大文件\n\ngitlfstrack\"*.psd\"\n\n", "大文件的存储和访问。\n\n###基本原理\n\nGitLFS通过将大文件的内容替换为指针，实际内容存储在服务器上，从而避免了大文件在仓库中的直接存储。\n\n###使用GitLFS\n\n```bash\n\n#安装GitLFS\n\ngitlfsinstall\n\n#跟踪大文件\n\ngitlfstrack\"*.psd\"\n\n#提交更改\ngitadd.gitattributesgitcommit-m\"Track.psdfilesusingGitLFS\"```\n\n#实用技巧\n\n##撤销与重做\n\n在使用Git时，我们有时会需要撤销之前的操作或者重做操作。以下是一些常用的撤销与重做操作命令：\n\n###撤销工作目录中的修改\n\n如果你对文件进行了修改，但是还没有进行提交，你可以使用以下命令来撤销工作目录中的修改：\n\n`bashgitcheckout--<file>`\n\n###撤销暂存区的文件\n\n如果你已经使用`gitadd`将文件添加到暂存区，但是想要撤销这一操作，可以使用以下命令：\n\n`bashgitresetHEAD<file>`\n\n###撤销提交\n\n如果你已经进行了提交，但是想要撤销这次提交，可以使用以下命令：\n\n`bashgitrevert<commit>`\n\n其中`<commit>`是你想要撤销的提交的哈希值。\n\n###重做提交\n\n如果你撤销了某次提交，但是后来又决定这次提交是正确的，想要重新应用这次提交，可以使用以下命令：\n\n`bashgitreset--hard<commit>`\n\n这将会重置当前分支到指定的提交。\n\n##日志搜索技巧\n\nGit提供了强大的日志搜索功能，可以帮助我们快速找到特定的提交信息。\n\n###搜索提交日志\n\n使用以下命令可以搜索提交日志：\n\n`bashgitlog--grep=<pattern>`\n\n", "ashgitreset--hard<commit>`\n\n这将会重置当前分支到指定的提交。\n\n##日志搜索技巧\n\nGit提供了强大的日志搜索功能，可以帮助我们快速找到特定的提交信息。\n\n###搜索提交日志\n\n使用以下命令可以搜索提交日志：\n\n`bashgitlog--grep=<pattern>`\n\n其中`<pattern>`是你想要搜索的关键词或正则表达式。\n###查看特定文件的变更记录\n\n如果你只对某个特定文件的变更记录感兴趣，可以使用以下命令：\n\n`bashgitlog-p<file>`\n\n这将显示该文件的每次提交差异。\n\n###查看某个范围内的提交\n\n你也可以指定查看某个时间范围内的提交：\n\n`bashgitlog--since=\"2weeksago\"--until=\"3daysago\"`\n\n这将显示从两周前到三天前的所有提交。\n\n##搭建Git服务器\n\n搭建Git服务器可以让团队成员共享代码库和协作开发。以下是搭建Git服务器的基本步骤：\n\n###安装Git\n\n首先确保服务器上安装了Git：\n\n`bashsudoapt-getinstallgit`\n\n###创建一个裸仓库\n\n在服务器上创建一个裸仓库：\n\n`bashgitinit--bare<repository.git>`\n\n###设置SSH访问\n\n确保团队成员的SSH公钥被添加到服务器的`~/.ssh/authorized_keys`文件中，以便他们可以通过SSH访问仓库。\n\n##Git与持续集成\n\nGit可以与持续集成(CI)系统结合使用，以自动化代码的构建、测试和部署流程。\n\n###集成CI服务\n\n你可以选择一个CI服务，如Jenkins、TravisCI或CircleCI，并按照服务提供商的指南将其与你的Git仓库集成。\n\n###配置构建脚本\n\n", "SSH访问仓库。\n\n##Git与持续集成\n\nGit可以与持续集成(CI)系统结合使用，以自动化代码的构建、测试和部署流程。\n\n###集成CI服务\n\n你可以选择一个CI服务，如Jenkins、TravisCI或CircleCI，并按照服务提供商的指南将其与你的Git仓库集成。\n\n###配置构建脚本\n\n在你的项目中添加一个构建脚本，例如`.travis.yml`或`Jenkinsfile`，并配置构建、测试和部署的命令。\n###自动触发构建\n\n每当有新的提交推送到仓库时，CI服务会自动触发构建流程，并反馈构建结果。\n\n##Git工作流程\n\nGit工作流程是指团队使用Git进行协作开发的一系列规范流程。以下是一些常见的Git工作流程：\n\n###FeatureBranchWorkflow\n\n特性分支工作流程中，每个新功能都在独立的分支上开发，完成后再合并到主分支：\n\n```bashgitcheckout-bfeature_branch\n\n#开发新功能\n\ngitcommit-am\"Addnewfeature\"gitcheckoutmastergitmergefeature_branch\n```\n\n###GitflowWorkflow\n\nGitflow工作流程定义了一个围绕项目发布的严格分支模型，包括功能分支、发布分支和维护分支。\n\n###ForkingWorkflow\n\n在Forking工作流程中，每个贡献者都有自己的服务器端仓库，他们可以自由地推送提交，然后通过拉取请求来贡献代码。\n\n以上是对实用技巧模块的详细介绍。\n\n#附录\n\n##常用Git命令清单\n\n在使用Git进行版本控制时，以下是一些常用的命令：\n\n*`gitinit`：在当前目录中初始化一个新的Git仓库。\n*`gitclone[url]`：克隆一个仓库到本地目录。\n", "可以自由地推送提交，然后通过拉取请求来贡献代码。\n\n以上是对实用技巧模块的详细介绍。\n\n#附录\n\n##常用Git命令清单\n\n在使用Git进行版本控制时，以下是一些常用的命令：\n\n*`gitinit`：在当前目录中初始化一个新的Git仓库。\n*`gitclone[url]`：克隆一个仓库到本地目录。\n*`gitadd[file]`：将文件添加到暂存区。*`gitcommit-m\"[commitmessage]\"`：将暂存区的内容提交到仓库。\n*`gitstatus`：查看仓库当前的状态，显示有变更的文件。\n*`gitpush[alias][branch]`：将本地分支的更新推送到远程仓库。\n*`gitpull[alias][branch]`：从远程仓库获取最新版本并合并到本地。\n*`gitbranch`：列出所有本地分支。\n*`gitbranch-a`：列出所有本地分支和远程分支。\n*`gitbranch[branch-name]`：创建新分支。\n*`gitcheckout[branch-name]`：切换到指定分支。\n*`gitmerge[branch]`：合并指定分支到当前分支。\n*`gitlog`：查看提交历史。\n*`gitdiff`：查看未暂存的文件更新了哪些部分。\n*`gitreset`：重置当前HEAD到指定状态。\n\n##Git配置文件解析\n\nGit配置文件`.gitconfig`通常位于用户主目录下，用于配置用户级别的Git选项。\n\n`ini[user]name=YourNameemail=you@example.com[alias]co=checkoutbr\n=branchci=commitst=status`\n\n*`[user]`部分用于设置提交代码时的用户信息。\n*`[alias]`部分可以设置命令的别名，简化命令输入。\n\n##Git错误处理\n\n处理Git错误时，首先应该使用`gitstatus`和`gitlog`检查当前状态和历史提交。以下是一些常见的Git错误处理方法：\n\n", "itst=status`\n\n*`[user]`部分用于设置提交代码时的用户信息。\n*`[alias]`部分可以设置命令的别名，简化命令输入。\n\n##Git错误处理\n\n处理Git错误时，首先应该使用`gitstatus`和`gitlog`检查当前状态和历史提交。以下是一些常见的Git错误处理方法：\n\n*当遇到合并冲突时，需要手动编辑文件解决冲突，然后使用`gitadd[file]`标记为已解决，最后提交。*如果需要撤销最近的提交，可以使用`gitreset--hardHEAD^`回退到上一个提交状态。\n*当本地分支落后于远程分支，需要合并远程变更时，可以使用`gitpull`来更新本地分支。\n\n##参考资料与进阶阅读\n\n以下是一些推荐的参考资料和进阶阅读：\n\n*ProGit书籍：深入理解Git的原理和使用方法。\n*Git官方文档：提供详细的命令参考和使用场景。\n*Git社区论坛：在社区中与其他开发者交流心得和技巧。\n\n\n", "#Git教程\n\n#Git简介\n\n##什么是Git\n\nGit是一种分布式版本控制系统，用于跟踪文件的变化并协作开发。它可以记录文件的修改历史，并允许多人在同一项目上进行协作开发。\n\n##Git的优势\n\n*分布式：每个开发者都拥有整个代码库的完整历史记录，无需依赖中央服务器。\n*高效：Git的分支和合并操作非常快速，使得并行开发变得更加容易。\n*强大的支持：Git支持大型项目、快速的存储和高效的处理能力。\n\n```bash\n\n#创建一个新的Git仓库\n\ngitinit```\n\n```bash\n\n#克隆一个现有的Git仓库\n\ngitclone<仓库地址>```\n\n```bash\n\n#将文件添加到暂存区\n\ngitadd<文件名>```\n\n```bash\n\n#提交文件\n\ngitcommit-m\"提交说明\"```\n\n#Git基础\n\n##Git的安装\n\n首先，您需要下载适用于您操作系统的Git安装程序。然后，按照安装向导的步骤进行安装。\n\n##创建仓库\n\n要在Git中创建一个新的仓库，可以使用以下命令：\n\n`bashgitinit`\n\n这将在当前目录中创建一个新的Git仓库。\n\n##添加文件\n\n要将文件添加到Git仓库，可以使用以下命令：\n\n`bashgitadd<文件名>`\n\n这将把指定的文件添加到暂存区。\n\n##提交更改\n\n一旦您对文件进行了修改并将其添加到暂存区，您可以使用以下命令提交更改：\n\n`bashgitcommit-m\"提交说明\"`\n\n这将提交您所做的更改并将其保存到仓库中。\n\n##查看提交历史\n\n要查看Git仓库的提交历史，可以使用以下命令：\n\n`bashgitlog`\n\n这将显示所有的提交历史记录，包括提交者信息、提交时间和提交说明。\n\n以上就是Git基础模块的内容。\n\n#分支管理\n\n", "hgitcommit-m\"提交说明\"`\n\n这将提交您所做的更改并将其保存到仓库中。\n\n##查看提交历史\n\n要查看Git仓库的提交历史，可以使用以下命令：\n\n`bashgitlog`\n\n这将显示所有的提交历史记录，包括提交者信息、提交时间和提交说明。\n\n以上就是Git基础模块的内容。\n\n#分支管理\n\n##创建分支\n要创建一个新的分支，可以使用以下命令：\n\n`bashgitbranch<branch_name>`\n\n这将创建一个名为`<branch_name>`的新分支，但并不会自动切换到这个分支。\n\n##切换分支\n\n要切换到已经存在的分支，可以使用以下命令：\n\n`bashgitcheckout<branch_name>`\n\n这将使当前工作目录切换到名为`<branch_name>`的分支上。\n\n##合并分支\n\n要将一个分支的更改合并到当前分支，可以使用以下命令：\n\n`bashgitmerge<branch_name>`\n\n这将把名为`<branch_name>`的分支合并到当前分支上。\n\n##解决冲突\n\n在合并分支时，如果发生冲突，需要手动解决冲突。可以通过编辑文件来解决冲突，然后使用以下命令标记文件为已解决冲突的状态：\n\n`bashgitadd<file_name>`\n\n解决完所有冲突后，可以继续合并分支。\n\n以上是关于Git分支管理的基本操作。\n\n#远程仓库\n\n##添加远程仓库\n\n要将本地仓库与远程仓库关联，可以使用以下命令：\n\n`bashgitremoteaddorigin远程仓库地址`\n\n其中，`origin`是远程仓库的别名，可以根据实际情况自行命名。\n\n##推送到远程仓库\n\n将本地提交推送到远程仓库可以使用以下命令：\n\n", "基本操作。\n\n#远程仓库\n\n##添加远程仓库\n\n要将本地仓库与远程仓库关联，可以使用以下命令：\n\n`bashgitremoteaddorigin远程仓库地址`\n\n其中，`origin`是远程仓库的别名，可以根据实际情况自行命名。\n\n##推送到远程仓库\n\n将本地提交推送到远程仓库可以使用以下命令：\n\n`bashgitpushorigin分支名`\n例如，将本地的`master`分支推送到远程仓库可以使用：\n\n`bashgitpushoriginmaster`\n\n##从远程仓库拉取\n\n从远程仓库拉取最新代码到本地可以使用以下命令：\n\n`bashgitpullorigin分支名`\n\n例如，从远程仓库拉取`master`分支的最新代码可以使用：\n\n`bashgitpulloriginmaster`\n\n##解决冲突\n\n在拉取或合并代码时，如果出现冲突，需要手动解决冲突并提交。可以通过编辑文件解决冲突后，再执行以下命令提交解决：\n\n`bashgitadd.gitcommit-m\"解决冲突\"gitpushorigin分支名`\n\n以上是关于远程仓库操作的基本内容。\n\n###高级主题\n\n####标签\n\n在Git中，标签是用来标记特定提交的版本号的。通过给提交打上标签，可以方便地在需要的时候找到该提交。创建标签可以使用`gittag`命令，例如：\n\n`bashgittagv1.0.0`\n\n####忽略文件\n\n有时候我们希望Git在进行版本控制时忽略某些文件，比如临时文件或者编译生成的文件。可以通过在项目根目录下创建一个名为`.gitignore`的文件，并在其中指定需要忽略的文件模式，例如：\n\n`plaintext*.logbuild/`\n\n####撤销操作\n\n", "agv1.0.0`\n\n####忽略文件\n\n有时候我们希望Git在进行版本控制时忽略某些文件，比如临时文件或者编译生成的文件。可以通过在项目根目录下创建一个名为`.gitignore`的文件，并在其中指定需要忽略的文件模式，例如：\n\n`plaintext*.logbuild/`\n\n####撤销操作\n\n在Git中，有时候我们需要撤销之前的操作，比如撤销暂存的文件或者撤销已提交的修改。可以使用`gitreset`命令来撤销暂存的文件，使用`gitrevert`命令来撤销已提交的修改。\n\n####Git工作流\n\nGit工作流是指团队协作时如何使用Git进行版本控制和代码管理的一种约定。常见的Git工作流包括集中式工作流、特性分支工作流、Gitflow工作流等。选择合适的工作流对团队的协作效率有很大的影响。\n\n#实用技巧\n\n##查看差异\n\n要查看文件的差异，可以使用以下命令：\n\n`bashgitdiff`\n\n##修改最后一次提交\n\n如果需要修改最后一次提交的信息，可以使用以下命令：\n\n`bashgitcommit--amend`\n\n##临时存储修改\n\n使用以下命令可以将当前工作目录中的修改临时存储起来：\n\n`bashgitstash`\n\n##重写提交历史\n\n如果需要重写提交历史，可以使用以下命令：\n\n`bashgitrebase-iHEAD~n`\n\n以上是关于Git实用技巧的详细内容。\n\n\n", "#GithubApi使用\n\n###GithubApi简介\n\n####什么是GithubApi\n\nGithubApi是Github提供的一组用于访问和操作Github数据的接口。通过Github\nApi，用户可以实现对仓库、提交、用户等资源的管理和操作。\n\n####GithubApi的优势\n\n***灵活性**：GithubApi提供了丰富的接口，可以满足各种不同的需求，用户可以根据自身需求进行定制化开发。\n***整合性**：GithubApi可以与其他服务和工具进行无缝整合，例如持续集成工具、项目管理工具等，提高工作效率。\n***实时性**：通过GithubApi，可以实时获取最新的仓库、提交等信息，帮助用户及时了解和响应变化。\n\n以上是GithubApi的简要介绍和优势。\n\n#GithubApi的基本用法\n\n##认证与权限\n\n在使用GithubApi之前，我们需要进行认证以获取相应的权限。GithubApi使用OAuth2.0\n进行认证，我们可以通过申请一个个人访问令牌（PersonalAccessToken）来进行认证。\n\n###申请个人访问令牌\n\n1.登录Github，点击头像进入Settings。\n2.在左侧菜单中选择Developersettings，然后点击Personalaccesstokens。\n3.点击Generatenewtoken，填写Tokendescription，并勾选需要的权限。\n4.点击Generatetoken，将生成的访问令牌保存好，之后将用于认证。\n\n###使用个人访问令牌进行认证\n\n在进行数据获取与操作时，需要在请求的Header中添加Authorization字段，其值为\"token\n\\<your_personal_access_token>\"。\n\n##数据获取与操作\n\nGithubApi提供了丰富的接口来获取和操作数据，包括获取仓库信息、提交记录、问题等。\n\n###获取仓库信息\n\n我们可以使用GithubApi来获取特定用户或组织的仓库信息，例如：\n\n```pythonimportrequests\n\nurl='https://api.github.com/users/octocat/repos'headers={'Authorization':\n'token'}response=requests.get(url,headers=headers)\n\nprint(response.json())```\n\n###提交操作\n\n", "/api.github.com/users/octocat/repos'headers={'Authorization':\n'token'}response=requests.get(url,headers=headers)\n\nprint(response.json())```\n\n###提交操作\n\n我们可以使用GithubApi来创建、更新和删除提交，例如：\n```pythonimportrequests\n\nurl='https://api.github.com/repos/octocat/Hello-World/contents/test.txt'\nheaders={'Authorization':'token'}data={\"message\":\"mycommitmessage\",\n\"content\":\"bXkgbmV3IGZpbGUgY29udGVudHM=\"#base64encodedcontent}response\n=requests.put(url,headers=headers,json=data)\n\nprint(response.json())```\n\n以上就是GithubApi的基本用法，包括认证与权限以及数据获取与操作。通过这些基本用法，我们可以在自己的应用中使用GithubApi\n来实现丰富的功能。\n\n#GithubApi的高级应用\n\n##Webhooks\n\nWebhooks是GithubApi中的一项高级功能，它允许用户在特定事件发生时自动触发自定义的HTTP回调。通过配置\nWebhooks，您可以实现对代码仓库中的各种事件进行监控和自动化处理，例如代码提交、Issue创建等。\n\n###配置Webhooks\n\n要配置Webhooks，您可以通过Github仓库的设置页面进行操作。在Webhooks页面，您可以添加新的Webhook，并指定触发\nWebhook的事件类型和回调URL。\n\n###Webhooks的工作原理\n\n当配置的事件类型在仓库中发生时，Github会向指定的回调URL发送HTTPPOST\n请求，请求中包含有关事件的详细信息。您可以编写自定义的服务器端代码来处理这些请求，实现自动化的业务逻辑。\n\n###示例代码\n\n以下是一个简单的Node.jsExpress服务器端代码示例，用于处理GithubWebhooks的HTTPPOST请求：\n\n```javascriptconstexpress=require('express');constbodyParser=\nrequire('body-parser');\n\n", "以下是一个简单的Node.jsExpress服务器端代码示例，用于处理GithubWebhooks的HTTPPOST请求：\n\n```javascriptconstexpress=require('express');constbodyParser=\nrequire('body-parser');\n\nconstapp=express();app.use(bodyParser.json());\napp.post('/webhook',(req,res)=>{constevent=req.get('X-GitHub-Event');\n//根据event类型处理业务逻辑res.sendStatus(200);});\n\napp.listen(3000,()=>{console.log('Webhook服务器已启动');});```\n\n##GithubActions\n\nGithubActions是Github\n提供的持续集成和持续部署（CI/CD）工具，它允许您在代码仓库中配置自定义的工作流程，以实现自动化的构建、测试和部署。\n\n###配置GithubActions\n\n要配置GithubActions，您可以在仓库中创建一个名为`.github/workflows`的目录，并在该目录中添加YAML\n格式的工作流程配置文件。在配置文件中，您可以定义工作流程的触发条件、执行步骤和环境。\n\n###GithubActions的工作原理\n\n当配置的触发条件满足时，Github会自动执行相应的工作流程。您可以在工作流程中使用Github\n提供的预定义动作（actions），也可以编写自定义的脚本来实现特定的构建、测试和部署操作。\n\n###示例代码\n\n以下是一个简单的GithubActions配置文件示例，用于在代码提交后自动运行测试并部署到服务器：\n\n```yamlname:CI/CD\n\non:push:branches:[main]\n\njobs:build:runs-on:ubuntu-latest\n\n\n\nsteps:\n-name:Checkoutcode\nuses:actions/checkout@v2\n\n-name:Runtests\nrun:npmtest\n\n-name:Deploytoserver\nrun:|\nsshuser@server'cd/path/to/app&&gitpull'\n\n\n```\n\n", "s:\n-name:Checkoutcode\nuses:actions/checkout@v2\n\n-name:Runtests\nrun:npmtest\n\n-name:Deploytoserver\nrun:|\nsshuser@server'cd/path/to/app&&gitpull'\n\n\n```\n\n以上是GithubApi的高级应用中Webhooks和GithubActions的详细内容。\n\n", "#GithubApi使用\n\n#GithubAPI简介\n\nGithubAPI是Github提供的一组接口，允许用户通过编程方式与Github进行交互。通过这些接口，用户可以获取Github\n仓库的信息、创建和修改仓库、管理issue和pullrequest等。\n\nGithubAPI支持多种编程语言，包括Python、Java、Ruby等。用户可以通过这些语言编写程序，调用GithubAPI\n接口，实现自动化操作。\n\n#GithubAPI功能\n\nGithubAPI提供了丰富的功能，包括但不限于：\n\n*获取仓库信息\n*创建和修改仓库\n*管理issue和pullrequest\n*获取用户信息\n*管理用户权限\n*搜索仓库和用户\n\n以下是一个简单的示例代码，演示如何使用Python调用GithubAPI获取仓库信息：\n\n```pythonimportrequests\n\ndefget_repo_info(owner,repo):url=\nf\"https://api.github.com/repos/{owner}/{repo}\"response=requests.get(url)if\nresponse.status_code==200:returnresponse.json()else:returnNone\n\n#调用函数获取仓库信息\n\nrepo_info=get_repo_info(\"octocat\",\"Hello-World\")ifrepo_info:\nprint(repo_info)else:print(\"获取仓库信息失败\")```\n\n以上代码中，我们使用`requests`库发送HTTP请求，获取仓库信息。如果请求成功，则返回JSON格式的仓库信息；如果请求失败，则返回\nNone。\n\n需要注意的是，在使用GithubAPI时，需要先进行身份验证，可以通过在请求头中添加`Authorization`字段来实现。\n\n#目录2\n\n##GithubApi使用方法\n\nGithubApi是一种用于\n\n#GithubAPI常见问题\n\n在使用GithubAPI时，可能会遇到一些常见问题，以下是一些可能遇到的问题及其解决方法。\n\n##问题1：无法获取\n\n\n", "#GithubApi使用\n\n#目录1\n\n##GithubApi简介\n\nGithubAPI是Github提供的一组接口，用于通过编程方式\n\n##GithubApi使用方法\n\nGithubApi是一种基于RESTful架构的API，它允许用户通过HTTP请求与Github进行交互。以下是使用GithubApi的基本步骤：\n\n###1\\.获取\n\n\n"]